package processtree;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.ListIterator;

/**
 * ProcessLicense
 * 
 * @author Kenneth Evans, Jr.<br>
 * <br>
 * 
 *         This class processes files related to licenses. It processes several
 *         types of files, depending on the value of mode: Java files, LICENSE
 *         files, and files related to the domain name.<br>
 * <br>
 * 
 *         Many of the parameters are static fields that must be changed and the
 *         program rebuilt to use them. See the comments above these variables.
 *         In particular note DRY_RUN and the limits for how many items to
 *         process. These provide some testing and safeguards. Note that this is
 *         a working tool and is not intended to be a production code, which is
 *         why you must change these fields by hand.<br>
 * <br>
 * 
 *         Java Files:<br>
 * <br>
 * 
 *         There are two different modes defined by DO_MATCH. When DO_MATCH is
 *         true, it processes Java files that match the requirements for having
 *         the old license. These requirements are defined by specifying lines
 *         to match in line1, line2, etc. These lines are used in
 *         checkOldLicense().<br>
 * <br>
 * 
 *         When doMatch is false, it processes Java files that don't match the
 *         license. It currently prints a prompt and asks before changing these.
 *         This mode can be used to add licenses to, for example, files
 *         generated by templates for plug-ins.<br>
 * <br>
 * 
 *         The current status of the files for either value of DO_MATCH can be
 *         found by using DRY_RUN = true and setting PROCESS_LIMIT, MATCH_LIMIT,
 *         and FAIL_LIMIT to Integer.MAX_VALUE. These work on files, not
 *         directories. Use PROJECT_LIMIT for projects.<br>
 * <br>
 * 
 *         LICENSE files:<br>
 * <br>
 * 
 *         This mode looks for LICENSE files with old text and converts them to
 *         a new text.
 * 
 *         DOMAIN files:<br>
 * <br>
 * 
 *         This mode converts from using a name like gov.anl.xrays to something
 *         like org.scatteringsw.xrays. It attempts to change this name
 *         everywhere it is used and also to rename the corresponding package
 *         directories.
 * 
 */
public class ProcessLicense extends ProcessTree
{
    // Whether to actually process or not
    private static final boolean DRY_RUN = false;
    // Set to list each project directory processed
    private static final boolean PRINT_PROJECT = true;
    // Set to list each file where the license if to be replaced
    private static final boolean PRINT_REPLACE_LICENCE_FILE = true;
    // Set to list each project directory skipped
    private static final boolean PRINT_SKIPPED_PROJECT = false;
    // Total number of (non-skipped) projects to process (Best left at
    // integer.MAX_VALUE)
    private static final int PROJECT_LIMIT = Integer.MAX_VALUE;
    // Total number of qualifying projects to process (Best left at
    // integer.MAX_VALUE)
    private static final int QUALIFYING_LIMIT = Integer.MAX_VALUE;
    // private static final int QUALIFYING_LIMIT = 1;
    // Total number of files to process (Best left at integer.MAX_VALUE)
    private static final int PROCESS_LIMIT = Integer.MAX_VALUE;
    // Number of files matching the old license to process
    // private static final int MATCH_LIMIT = 2;
    private static final int MATCH_LIMIT = Integer.MAX_VALUE;
    // Number of files not matching the old license to process
    private static final int FAIL_LIMIT = Integer.MAX_VALUE;
    // Set to do files that match or do not match the old license in Java mode.
    private static final boolean DO_MATCH = true;
    // Number of preview lines to print if there is a prompt
    private static final int N_PRINT_LINES = 8;
    // Set to check line endings. It is probably not necessary to check line
    // endings, as processed files will have the line ending used by println.
    // The
    // code may not work if this is false, but it could be fixed up.
    private static final boolean CHECK_CRLF = true;
    // List of binary file extensions
    public String[] binaryExtensions = {".jar", ".class", ".zip", ".gz",
        ".exe", ".dll", ".so", ".ico"};

    // The Work directory. Leave the \'s as it will be used for a pattern match
    private static final String WORK_DIR = "C:\\eclipseWorkspaces\\Work\\";
    private static final int PROJECT_INDEX = WORK_DIR.length();
    // The name of the file that has projects to skip.
    private static final String SKIP_FILE = "Data/SkipProjects.txt";
    // The name of the file that has the new license lines for Java files
    private static final String LICENSE_JAVA_FILE = "Data/BlankLicense.txt";
    // The name of the file that has the new license lines for text license
    // files
    private static final String LICENSE_TEXT_FILE = "Data/BlankLicense.txt";

    // Setup to define the requirements for finding the old license. Used in
    // checkOldLicense and during replacement. The length of this String must be
    // equal to the number of lines in the old license. Lines that are null,
    // however, will not be checked.

    // private static String[] oldLicenseCheckLines = {
    // "/****************************************************************************\\",
    // null,
    // null,
    // " * This file is distributed subject to a Software License Agreement found",
    // " * in the file LICENSE that is included with this distribution.",
    // " ****************************************************************************/",};
    private static String[] oldLicenseCheckLines = {
        "/*******************************************************************************",
        " * Copyright © 2007, UChicago Argonne, LLC", " *",
        " * All Rights Reserved", " *", " * X-Ray Analysis Software (XRAYS)",
        null, null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null,};
    // This is the number of lines we are checking. It may be less than the
    // number of lines in the old license.
    private static final int N_OLD_LICENSE_CHECK_LINES = oldLicenseCheckLines.length;

    // Setup for domain name change
    private static final String oldDomainName = "gov.anl.xrays";
    private static final String newDomainName = "org.scatteringsw.xrays";
    private static final String[] oldDirs = oldDomainName.split("\\.");
    private static final String[] newDirs = newDomainName.split("\\.");
    private final boolean CHECK_ALL_PROJECTS_FOR_DOMAIN_REFERENCES = true;
    // Use this to repair clobbered binary files
    private final boolean FIX_BINARY = false;
    // Use this to skip files if the to and from dates are the same
    private boolean CHECK_DATE = true;

    // A convenience definition. Leave as is.
    public static final String LS = System.getProperty("line.separator");
    // The separator around preview lines when there is a prompt
    private static String SEPARATOR = "-----------------------------------------"
        + LS;

    // Major modes for the application
    public static enum Mode {
        LICENSE, JAVA, DOMAIN,
    };

    private Mode mode = Mode.JAVA;

    // Global variables (no configuration involved)
    private Comparator<File> fileComparator = null;
    private boolean abort = false;

    public static final int LF_MASK = 1;
    public static final int CR_MASK = 2;
    public static final int MIXED_CRLF_MASK = 4;

    private int nProjects = 0;
    private int nProcessed = 0;
    private int nMatch = 0;
    private int nFail = 0;
    private int nConv = 0;
    private int nCR = 0;
    private int nLF = 0;
    private int nCRLF = 0;
    private int nMixed = 0;
    private int nQualifying = 0;

    private String[] skippedProjects = null;
    private String[] licenseLines = null;
    private String[] licenseTextLines = null;
    InputStreamReader stdinStreamReader = null;
    BufferedReader stdinReader = null;

    /**
     * ProcessLicense constructor.
     */
    public ProcessLicense() {
        super();
        dirList.add(WORK_DIR);
        fileComparator = new Comparator<File>() {
            public int compare(File fa, File fb) {
                if(fa.isDirectory() && !fb.isDirectory()) return -1;
                if(fb.isDirectory() && !fa.isDirectory()) return 1;
                return (fa.getName().compareTo(fb.getName()));
            }
        };

        // Initialize
        try {
            System.out.println("Processing:" + LS + WORK_DIR + LS);
            // Skipped projects file
            getSkippedProjectsList();
            if(skippedProjects == null) {
                System.out.println("No skipped projects");
            } else {
                System.out.print("Skipped projects [" + skippedProjects.length
                    + "]");
                System.out.println(" from " + SKIP_FILE);
            }
            if(mode == Mode.LICENSE) {
                // Textlicense lines
                getLicenseTextLines();
                if(licenseTextLines == null) {
                    System.out.println("No text license file");
                } else {
                    System.out.print("Text license lines");
                    System.out.println(" from " + LICENSE_TEXT_FILE);
                }
            } else if(mode == Mode.JAVA) {
                // License lines
                getLicenseLines();
                if(licenseLines == null) {
                    System.out.println("No license file");
                } else {
                    System.out.print("License java lines");
                    System.out.println(" from " + LICENSE_JAVA_FILE);
                }
                int nChecked = 0;
                for(String line : oldLicenseCheckLines) {
                    if(line != null) {
                        nChecked++;
                    }
                }
                System.out.println("Checking " + nChecked + " of "
                    + N_OLD_LICENSE_CHECK_LINES + " lines in the old license");
            }
            // Finish
            System.out.println();
        } catch(Exception ex) {
            // System.err.println("Failed to initialize:" + LS + ex + LS
            // + ex.getMessage());
            ex.printStackTrace();
            System.exit(1);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see processtree.ProcessTree#processBefore(java.lang.Object)
     */
    public void processBefore(Object obj) {
    }

    /*
     * (non-Javadoc)
     * 
     * @see processtree.ProcessTree#processBetween(java.lang.Object)
     */
    public void processBetween(Object obj) {
    }

    /*
     * (non-Javadoc)
     * 
     * @see processtree.ProcessTree#processEnd(java.lang.Object)
     */
    public void processEnd(Object obj) {
        if(mode == Mode.JAVA) {
            System.out
                .printf(
                    "\nnConv=%d nMatch=%d nFail=%d nCRLF=%d nLF=%d nCR=%d nMixed=%d\n",
                    nConv, nMatch, nFail, nCRLF, nLF, nCR, nMixed);
        } else if(mode == Mode.DOMAIN) {
            System.out.printf("\nnProjects=%d nQualifying=%d\n", nProjects,
                nQualifying);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see processtree.ProcessTree#process(java.lang.Object)
     */
    public void process(Object obj) {
        File item = (File)obj;
        boolean fitsDomain = false;
        try {
            if(item == null) {
                return;
            }
            level++;
            if(item.isDirectory()) {
                if(level == 2) {
                    if(nProjects >= PROJECT_LIMIT) return;
                    if(nQualifying >= QUALIFYING_LIMIT) return;
                    if(isSkippedProject(item)) {
                        if(PRINT_SKIPPED_PROJECT) {
                            System.out.println("Project: " + item.getName()
                                + " [Skipped]" + LS);
                        }
                        return;
                    }
                    nProjects++;
                    if(PRINT_PROJECT) {
                        System.out.println("Project: " + item.getName() + LS);
                    }
                    if(mode == Mode.LICENSE) {
                        if(!textLicenseExists(item)) {
                            String name = item.getPath() + "/LICENSE";
                            File licenseFile = new File(name);
                            processLicense(licenseFile);
                            // Don't process the directory further
                            return;
                        }
                    } else if(mode == Mode.DOMAIN) {
                        fitsDomain = isQualifyingProject(item);
                        if(fitsDomain) nQualifying++;
                        // Don't process the directory further if it doesn't fit
                        // the pattern
                        if(!CHECK_ALL_PROJECTS_FOR_DOMAIN_REFERENCES
                            && !fitsDomain) {
                            return;
                        }
                    }
                }
                File dirList[] = item.listFiles();
                // Convert it to a list so we can sort it
                List<File> list = Arrays.asList(dirList);
                Collections.sort(list, fileComparator);
                ListIterator<File> iter = list.listIterator();
                while(iter.hasNext()) {
                    File file1 = (File)iter.next();
                    process((Object)file1);
                }
                if(level == 2 && mode == Mode.DOMAIN) {
                    processDomain(item);
                    System.out.println();
                }
            } else {
                processFile(item);
            }
        } catch(Exception ex) {
            System.err.println("Processing error:" + LS + ex + LS
                + ex.getMessage());
            System.err.println();
        } finally {
            level--;
        }
    }

    /**
     * Method to process a file.
     * 
     * @param file
     */
    void processFile(File file) {
        if(nProcessed >= PROCESS_LIMIT) return;
        if(DO_MATCH && nMatch >= MATCH_LIMIT) return;
        if(!DO_MATCH && nFail >= FAIL_LIMIT) return;
        if(mode == Mode.LICENSE) {
            String name = file.getPath();
            if(name.endsWith("LICENSE")) {
                processLicense(file);
            }
        } else if(mode == Mode.JAVA) {
            String name = file.getPath();
            if(name.endsWith(".java")) {
                processJava(file);
            }
        } else if(mode == Mode.DOMAIN) {
            // Process all files in this domain
            if(level >= 2) {
                try {
                    processDomainFile(file);
                } catch(Exception ex) {
                    ex.printStackTrace();
                    abort = true;
                    return;
                }
            }
        }
        if(abort) {
            System.out.println(LS + "Aborted");
            System.exit(1);
        }
        nProcessed++;
    }

    /**
     * Checks if the project name starts with the old domain name.
     * 
     * @param file
     * @return
     */
    boolean isQualifyingProject(File file) {
        if(file == null) return false;
        if(!file.getName().startsWith(oldDomainName)) return false;
        return true;
    }

    /**
     * Method to process a project. Does nothing if it is not a qualifying
     * project.
     * 
     * @param file
     * @throws IOException
     */
    void processDomain(File file) {
        if(file == null) return;

        boolean goToProcess = false;
        boolean processProject = false;
        boolean processFirstLevel = false;
        boolean processSecondLevel = false;
        boolean processThirdLevel = false;

        // Check the hierarchy
        if(!file.getName().startsWith(oldDomainName)) return;
        // System.out.println(file.getName());
        processProject = true;

        // Process the structure
        File dirs[] = null;
        File curDir = file;

        // Check if next directory is src
        boolean found = false;
        dirs = curDir.listFiles();
        for(int i = 0; i < dirs.length; i++) {
            File dir = dirs[i];
            if(dir.isDirectory() && dir.getName().equals("src")) {
                found = true;
                curDir = dir;
                break;
            }
        }
        if(!found) {
            System.out.println("[src folder not found]");
            goToProcess = true;
        }

        // Check the first level
        if(!goToProcess) {
            found = false;
            dirs = curDir.listFiles();
            for(int i = 0; i < dirs.length; i++) {
                File dir = dirs[i];
                if(dir.isDirectory() && dir.getName().equals(oldDirs[0])) {
                    found = true;
                    curDir = dir;
                    break;
                }
            }
            if(!found) {
                System.out.println("[" + oldDirs[0] + " not found]");
                goToProcess = true;
            } else {
                processFirstLevel = true;
            }
        }

        // Check the second level
        if(!goToProcess) {
            found = false;
            dirs = curDir.listFiles();
            for(int i = 0; i < dirs.length; i++) {
                File dir = dirs[i];
                if(dir.isDirectory() && dir.getName().equals(oldDirs[1])) {
                    found = true;
                    curDir = dir;
                    break;
                }
            }
            if(!found) {
                System.out.println("[" + oldDirs[1] + " not found]");
                goToProcess = true;
            } else {
                processSecondLevel = true;
            }
        }

        // Check the third level
        if(!goToProcess) {
            found = false;
            dirs = curDir.listFiles();
            for(int i = 0; i < dirs.length; i++) {
                File dir = dirs[i];
                if(dir.isDirectory() && dir.getName().equals(oldDirs[2])) {
                    found = true;
                    curDir = dir;
                    break;
                }
            }
            if(!found) {
                System.out.println("[" + oldDirs[2] + " not found]");
                return;
            } else {
                processThirdLevel = true;
            }
        }

        // Actually do the processing
        String projName = file.getPath();
        // int projIndex = projName.indexOf(oldDomainName);
        // String dirName = projName.substring(0, projIndex);
        File src = null;
        File dst = null;
        if(false && processThirdLevel) {
            System.out.println(oldDirs[2] + " processed");
        }
        if(processSecondLevel) {
            src = new File(projName + "\\src\\" + oldDirs[0] + "\\"
                + oldDirs[1]);
            dst = new File(projName + "\\src\\" + oldDirs[0] + "\\"
                + newDirs[1]);
            renameFile(src, dst);
            System.out.println(oldDirs[1] + " processed");
        }
        if(processFirstLevel) {
            src = new File(projName + "\\src\\" + oldDirs[0]);
            dst = new File(projName + "\\src\\" + newDirs[0]);
            renameFile(src, dst);
            System.out.println(oldDirs[0] + " processed");
        }
        if(processProject) {
            src = new File(projName);
            dst = new File(projName.replaceFirst(oldDomainName, newDomainName));
            renameFile(src, dst);
            System.out.println("project processed");
        }
    }

    boolean renameFile(File src, File dst) {
        boolean result = true;
        if(DRY_RUN) {
            System.out.print("Simulated: ");
        } else {
            if(dst.exists()) {
                System.err.println("Destination exists: " + dst);
                System.err.println("Aborting rename");
                System.err.flush();
                return false;
            } else {
                result = src.renameTo(dst);
            }
        }
        System.out.println(src);
        System.out.println(" > " + dst);
        System.out.flush();
        if(!result) {
            System.err.println("Error renaming " + src);
            System.err.flush();
        }
        return result;
    }

    /**
     * Method to process a DOMAIN file.
     * 
     * @param file
     * @throws IOException
     */
    void processDomainFile(File file) throws IOException {
        if(file == null) return;
        if(FIX_BINARY) {
            fixBinary(file);
        } else {
            replacePatternInDomainFile(file);
        }
    }

    /**
     * Method to process a LICENSE file.
     * 
     * @param file
     */
    void processLicense(File file) {
        if(file == null) return;

        System.out.println(file.getPath());
        replaceTextLicense(file, null, true);
    }

    /**
     * Method to process a .java file.
     * 
     * @param file
     */
    void processJava(File file) {
        if(file == null) return;

        String projectName = file.getPath().substring(PROJECT_INDEX);

        // Get line ending type
        String type = "";
        try {
            type = getLineEndingType(file);
        } catch(Exception ex) {
            ex.printStackTrace();
            abort = true;
            return;
        }

        // Check for new license
        boolean match;
        try {
            match = checkCurrentJavaLicense(file);
            if(match) {
                nConv++;
                return;
            }
        } catch(Exception ex) {
            ex.printStackTrace();
            abort = true;
            return;
        }

        // Check for old license
        try {
            match = checkOldLicense(file);
            if(match) {
                nMatch++;
            } else {
                nFail++;
            }
        } catch(Exception ex) {
            ex.printStackTrace();
            abort = true;
            return;
        }

        // Process file
        if(DO_MATCH && match) {
            System.out.printf("%d %s %s\n", nMatch, projectName, type);
            if(licenseLines == null) {
                System.out.println("No license file: Cannot continue");
                abort = true;
                return;
            }
            replaceLicense(file, type, true, false);
        }
        if(!DO_MATCH && !match) {
            System.out.printf("%d %s %s\n", nFail, projectName, type);
            if(licenseLines == null) {
                System.out.println("No license file: Cannot continue");
                abort = true;
                return;
            }
            replaceLicense(file, type, false, true);
        }
    }

    /**
     * Checks if a project is in the skipped projects list.
     * 
     * @param file A File corresponding to the project directory.
     * @return
     */
    boolean isSkippedProject(File file) {
        boolean retVal = false;
        String inName = file.getPath();
        if(skippedProjects != null) {
            for(int i = 0; i < skippedProjects.length; i++) {
                if(inName.startsWith(WORK_DIR + skippedProjects[i]))
                    return true;
                // Handle project name with ending "\" such as "ISAW\" to
                // distinguidh
                // "ISAW" from "ISAWTest"
                if((inName + "\\").startsWith(WORK_DIR + skippedProjects[i]))
                    return true;
            }
        }
        return retVal;
    }

    /**
     * Checks for CR and LF. Returns a value with the bits set according to what
     * is found. The return value can be checked by ANDing with LF_MASK,
     * CR_MASK, or MIXED_CRLF_MASK. The latter bit is set if the is at least one
     * CR and the number of CRs and LFs differ.
     * 
     * @param bytes
     * @return
     */
    public int checkCRLF(byte[] bytes) {
        if(!CHECK_CRLF) return 0;
        int retVal = 0;
        byte b;
        int nCR = 0;
        int nLF = 0;
        for(int i = 0; i < bytes.length; i++) {
            b = bytes[i];
            if(b == 0x0a) {
                retVal |= LF_MASK;
                nLF++;
            } else if(b == 0x0d) {
                retVal |= CR_MASK;
                nCR++;
            }
        }
        if(nCR != 0 && nCR != nLF) {
            retVal |= MIXED_CRLF_MASK;
        }
        return retVal;
    }

    /**
     * Gets the line separator as a String.
     * 
     * @param file
     * @return
     * @throws IOException
     */
    public String getLineEndingType(File file) throws IOException {
        String type = "";
        byte[] bytes = loadFileBytes(file);
        int crlf = checkCRLF(bytes);
        if((crlf & LF_MASK) != 0 && (crlf & CR_MASK) != 0) {
            nCRLF++;
            type = "CRLF";
        } else if((crlf & LF_MASK) != 0) {
            nLF++;
            type = "LF";
        } else if((crlf & CR_MASK) != 0) {
            nCR++;
            type = "CR";
        }
        if((crlf & MIXED_CRLF_MASK) != 0) {
            nMixed++;
            type = "Mixed";
        }
        return type;
    }

    /**
     * Returns the contents of a file as a byte array.
     * 
     * @param file
     * @return
     * @throws IOException
     */
    public byte[] loadFileBytes(File file) throws IOException {
        if(file == null) return null;
        if(!file.exists()) {
            throw new IOException("File does not exist");
        }
        int len = (int)file.length();
        // if(len == 0) {
        // throw new IOException("File is empty");
        // }
        byte bytes[] = new byte[len]; // Has to be int here
        int nRead = 0;
        FileInputStream in = null;
        try {
            in = new FileInputStream(file);
            nRead = in.read(bytes);
            if(nRead != len) {
                throw new IOException("Only read " + nRead + " of " + len
                    + " bytes");
            }
            return bytes;
        } finally {
            if(in != null) in.close();
        }
    }

    /**
     * Returns the contents of a file as a String.
     * 
     * @param file
     * @return
     * @throws IOException
     */
    public String loadFileString(File file) throws IOException {
        byte[] bytes = loadFileBytes(file);
        if(bytes == null) return null;
        return new String(bytes);
    }

    /**
     * Determines if the file has the current text license.
     * 
     * @param file
     * @return
     * @throws IOException
     */
    public boolean checkCurrentTextLicense(File file) throws IOException {
        // Check for current text license
        boolean match = true;
        BufferedReader in = null;
        try {
            in = new BufferedReader(new FileReader(file));
            String line;
            int lineNum = 0;
            while((line = in.readLine()) != null) {
                if(!line.equals(licenseTextLines[lineNum])) {
                    match = false;
                    break;
                }
                lineNum++;
            }
        } catch(Exception ex) {
            match = false;
        } finally {
            if(in != null) in.close();
        }
        return match;
    }

    /**
     * Determines if the file has the current Java license. In the case there
     * are no lines in the current Java license, then by convention it will
     * return false.
     * 
     * @param file
     * @return
     * @throws IOException
     */
    public boolean checkCurrentJavaLicense(File file) throws IOException {
        // Check for current text license
        boolean match = true;
        BufferedReader in = null;
        int nLines = licenseLines.length;
        // If there are no lines in the current text license, return true
        if(nLines == 0) {
            return false;
        }
        try {
            in = new BufferedReader(new FileReader(file));
            String line;
            int lineNum = 0;
            while((line = in.readLine()) != null && lineNum < nLines) {
                if(!line.equals(licenseLines[lineNum])) {
                    match = false;
                    break;
                }
                lineNum++;
            }
            if(line == null) match = false;
        } catch(Exception ex) {
            match = false;
        } finally {
            if(in != null) in.close();
        }
        return match;
    }

    /**
     * Determines if the file has the old license.
     * 
     * @param file
     * @return
     * @throws IOException
     */
    public boolean checkOldLicense(File file) throws IOException {
        // Check for old license
        boolean match = true;
        BufferedReader in = null;
        try {
            in = new BufferedReader(new FileReader(file));
            String line;
            int lineNum = 0;
            // Check the first few lines
            while((line = in.readLine()) != null
                && lineNum < N_OLD_LICENSE_CHECK_LINES) {
                if(oldLicenseCheckLines[lineNum] != null
                    && !line.startsWith(oldLicenseCheckLines[lineNum])) {
                    match = false;
                    break;
                }
                lineNum++;
            }
        } catch(Exception ex) {
            match = false;
        } finally {
            if(in != null) in.close();
        }
        return match;
    }

    /**
     * Reads the list of projects to skip.
     * 
     * @throws IOException
     */
    public void getSkippedProjectsList() throws IOException {
        skippedProjects = null;
        File file = new File(SKIP_FILE);
        if(file == null || !file.exists()) {
            return;
        }
        ArrayList<String> arrayList = new ArrayList<String>(10);
        String line = null;
        BufferedReader in = null;
        try {
            in = new BufferedReader(new FileReader(SKIP_FILE));
            while((line = in.readLine()) != null) {
                if(line.startsWith("#", 0)) continue;
                arrayList.add(line);
            }
            skippedProjects = new String[arrayList.size()];
            arrayList.toArray(skippedProjects);
        } finally {
            if(in != null) in.close();
        }
    }

    /**
     * Gets the lines of the new license.
     * 
     * @throws IOException
     */
    public void getLicenseLines() throws IOException {
        licenseLines = null;
        File file = new File(LICENSE_JAVA_FILE);
        if(file == null || !file.exists()) {
            return;
        }
        ArrayList<String> arrayList = new ArrayList<String>(10);
        String line = null;
        BufferedReader in = null;
        try {
            in = new BufferedReader(new FileReader(LICENSE_JAVA_FILE));
            while((line = in.readLine()) != null) {
                arrayList.add(line);
            }
            licenseLines = new String[arrayList.size()];
            arrayList.toArray(licenseLines);
        } finally {
            if(in != null) in.close();
        }
    }

    /**
     * Gets the lines of the new text license.
     * 
     * @throws IOException
     */
    public void getLicenseTextLines() throws IOException {
        licenseTextLines = null;
        File file = new File(LICENSE_TEXT_FILE);
        if(file == null || !file.exists()) {
            return;
        }
        ArrayList<String> arrayList = new ArrayList<String>(10);
        String line = null;
        BufferedReader in = null;
        try {
            in = new BufferedReader(new FileReader(LICENSE_TEXT_FILE));
            while((line = in.readLine()) != null) {
                arrayList.add(line);
            }
            licenseTextLines = new String[arrayList.size()];
            arrayList.toArray(licenseTextLines);
        } finally {
            if(in != null) in.close();
        }
    }

    /**
     * Prints the first nLines lines of a file.
     * 
     * @param file
     * @param nLines
     */
    public void printFirstLines(File file, int nLines) {
        if(!file.exists()) {
            System.out.println(file.getName() + " does not exist");
            return;
        }
        BufferedReader in = null;
        try {
            in = new BufferedReader(new FileReader(file));
            String line;
            int lineNum = 0;
            while((line = in.readLine()) != null && lineNum < nLines) {
                lineNum++;
                System.out.println(line);
            }
        } catch(Exception ex) {
            ex.printStackTrace();
        } finally {
            try {
                if(in != null) in.close();
            } catch(IOException ex) {
                ex.printStackTrace();
                abort = true;
                return;
            }
        }
    }

    /**
     * Method that adds or replaces the license in a Java file. The old file is
     * renamed to a backup, which is deleted on success.
     * 
     * @param file
     * @param type The line-separator type. (Currently not used.)
     * @param replace Whether to replace the old license or to just add the new
     *            license.
     * @param prompt Whether to prompt for changing the license. Typically used
     *            when replace is false for security.
     */
    public void replaceLicense(File file, String type, boolean replace,
        boolean prompt) {
        if(PRINT_REPLACE_LICENCE_FILE) {
            if(replace) {
                System.out.print("Replace ");
            } else {
                System.out.print("Add ");
            }
            System.out.println(file.getPath());
        }
        if(DRY_RUN) return;
        if(prompt) {
            System.out.print(SEPARATOR);
            printFirstLines(file, N_PRINT_LINES);
            System.out.print(SEPARATOR);
            try {
                System.out.print("Continue [Y/n]? ");
                if(stdinReader == null) {
                    // Create stdin reader
                    stdinStreamReader = new InputStreamReader(System.in);
                    stdinReader = new BufferedReader(stdinStreamReader);
                }
                String input = stdinReader.readLine();
                input = input.toLowerCase();
                if(input.length() > 0 && !input.startsWith("y")) {
                    System.out.println("  Skipped");
                    return;
                }
            } catch(IOException ex) {
                System.out.println("Prompt error: " + LS + ex + LS
                    + ex.getMessage());
                System.out.println("  Skipped");
                return;
            }
        }
        String inName = file.getPath();
        String bkpName = inName + ".BKP";
        File bkpFile = new File(bkpName);
        Boolean result;
        if(bkpFile.exists()) {
            result = bkpFile.delete();
            if(!result) {
                System.err.println("Failed to delete existing backup file:"
                    + LS + bkpFile.getPath());
                abort = true;
                return;
            }
        }
        result = file.renameTo(bkpFile);
        if(!result) {
            System.err.println("Failed to rename original file:" + LS
                + bkpFile.getPath());
            abort = true;
            return;
        }
        // Do it
        BufferedReader in = null;
        PrintWriter out = null;
        try {
            in = new BufferedReader(new FileReader(bkpFile));
            out = new PrintWriter(new FileWriter(file));
            String line;
            int lineNum = 0;
            boolean added = false;
            while((line = in.readLine()) != null) {
                lineNum++;
                if(replace && lineNum <= N_OLD_LICENSE_CHECK_LINES) continue;
                if(!added) {
                    added = true;
                    for(int i = 0; i < licenseLines.length; i++) {
                        out.println(licenseLines[i]);
                    }
                    if(!replace && licenseLines.length > 0) {
                        // Add a blank line unless the new license has no lines
                        out.println();
                    }
                }
                out.println(line);
            }
            // Cleanup
            in.close();
            out.close();
            in = null;
            out = null;
            if(file.exists()) {
                result = bkpFile.delete();
                if(!result) {
                    System.err.println("Failed to delete backup file:" + LS
                        + bkpFile.getPath());
                    abort = true;
                    return;
                }
            }
            System.out.println("  Done");
        } catch(Exception ex) {
            ex.printStackTrace();
        } finally {
            try {
                if(in != null) in.close();
                if(out != null) out.close();
            } catch(IOException ex) {
                ex.printStackTrace();
                abort = true;
                return;
            }
        }
    }

    /**
     * Method that replaces the domain string in a file. The old file is renamed
     * to a backup, which is deleted on success. Only non-binary files that
     * actually contain the old domain name are processed.
     * 
     * @param file
     */
    public void replacePatternInDomainFile(File file) {
        // Don't do binary files or files that don't contain the old domain
        // string
        if(isBinary(file)) return;
        if(!hasOldDomainName(file)) return;

        System.out.println(file.getName());
        if(DRY_RUN) return;

        // Create a backup
        File bkpFile = null;
        Boolean result;
        String inName = file.getPath();
        String bkpName = inName + ".BKP";
        bkpFile = new File(bkpName);
        if(bkpFile.exists()) {
            result = bkpFile.delete();
            if(!result) {
                System.err.println("Failed to delete existing backup file:"
                    + LS + bkpFile.getPath());
                abort = true;
                return;
            }
        }
        result = file.renameTo(bkpFile);
        if(!result) {
            System.err.println("Failed to rename original file:" + LS
                + bkpFile.getPath());
            abort = true;
            return;
        }

        // Process the file
        BufferedReader in = null;
        PrintWriter out = null;
        try {
            in = new BufferedReader(new FileReader(bkpFile));
            out = new PrintWriter(new FileWriter(file));
            // Convert lines
            String line, newLine;
            // int lineNum = 0;
            while((line = in.readLine()) != null) {
                // lineNum++;
                newLine = line.replaceAll(oldDomainName, newDomainName);
                out.println(newLine);
            }

            // Cleanup
            if(in != null) in.close();
            if(out != null) out.close();
            in = null;
            out = null;
            if(!DRY_RUN && file.exists()) {
                result = bkpFile.delete();
                if(!result) {
                    System.err.println("Failed to delete backup file:" + LS
                        + bkpFile.getPath());
                    abort = true;
                    return;
                }
            }
        } catch(Exception ex) {
            ex.printStackTrace();
        } finally {
            try {
                if(in != null) in.close();
                if(out != null) out.close();
            } catch(IOException ex) {
                ex.printStackTrace();
                abort = true;
                return;
            }
        }
    }

    /**
     * Method that copies binary files from a backup. Can be used if binary
     * files were processed by mistake. Much of this routine is hard coded, and
     * should be checked before running.
     * 
     * @param toFile is the file to be fixed.
     */
    public void fixBinary(File toFile) {
        // Only do binary files
        if(!isBinary(toFile)) return;

        File fromFile = null;
        String toName = toFile.getPath();
        // Don't do .class files
        if(toFile.getPath().endsWith(".class")) return;
        String fromName = toName.replaceAll(
            "C:\\\\Documents and Settings\\\\evans\\\\My Documents",
            "J:\\\\Copy of My Documents");
        fromName = fromName.replaceAll(newDomainName, oldDomainName);
        fromFile = new File(fromName);
        if(!fromFile.exists()) {
            System.err.println("From file does not exist:");
            System.err.println("  " + fromName);
            return;
        }
        long toDate = toFile.lastModified();
        long fromDate = fromFile.lastModified();
        if(CHECK_DATE && toDate == fromDate) return;
        if(DRY_RUN) {
            System.out.println(fromName);
            System.out.println("-> " + toName);
            System.out.println(" [" + toFile.getName() + " "
                + timeStamp(fromDate) + "  " + timeStamp(toDate) + "]");
        } else {
            String cmd = "cmd.exe /c copy /b /y /v \"" + fromName + "\" \""
                + toName + "\"";
            System.out.println(cmd);
            System.out.flush();
            boolean test = true;
            // Use this to check the command line without actually running
            if(test) return;
            try {
                Runtime.getRuntime().exec(cmd);
            } catch(IOException ex) {
                System.err.println("Copy error:" + LS + ex + LS
                    + ex.getMessage());
                System.err.println();
                System.exit(1);
            }
        }
    }

    /**
     * Check if a LICENSE file exists.
     * 
     * @param file Must be a directory.
     * @return
     */
    public boolean textLicenseExists(File file) {
        if(!file.isDirectory()) {
            System.err.println("Must be a directory: " + file.getName());
            abort = true;
            return false;
        }
        String name = file.getPath() + "/LICENSE";
        File licenseFile = new File(name);
        return licenseFile.exists();
    }

    /**
     * Method that adds or replaces the license in a Java file. The old file is
     * renamed to a backup, which is deleted on success.
     * 
     * @param file
     * @param type The line-separator type. (Currently not used.)
     * @param replace Whether to replace the old license or to just add the new
     *            license.
     * @param prompt Whether to prompt for changing the license. Typically used
     *            when replace if false for security.
     */
    public void replaceTextLicense(File file, String type, boolean prompt) {
        if(prompt) {
            Boolean isCurrent = false;
            try {
                isCurrent = checkCurrentTextLicense(file);
            } catch(IOException ex) {
                isCurrent = false;
            }
            if(isCurrent) {
                System.out.print(SEPARATOR);
                System.out.println("License is current");
                System.out.print(SEPARATOR);
                System.out.println();
                return;
            } else {
                System.out.print(SEPARATOR);
                printFirstLines(file, N_PRINT_LINES);
                System.out.print(SEPARATOR);
            }
            if(DRY_RUN) {
                System.out.println();
                return;
            }
            try {
                System.out.print("Continue [Y/n]? ");
                if(stdinReader == null) {
                    // Create stdin reader
                    stdinStreamReader = new InputStreamReader(System.in);
                    stdinReader = new BufferedReader(stdinStreamReader);
                }
                String input = stdinReader.readLine();
                input = input.toLowerCase();
                if(input.length() > 0 && !input.startsWith("y")) {
                    System.out.println("  Skipped");
                    return;
                }
            } catch(IOException ex) {
                System.out.println("Prompt error: " + LS + ex + LS
                    + ex.getMessage());
                System.out.println("  Skipped" + LS);
                return;
            }
        }
        // Do it
        Boolean result = false;
        // Check if there are text license lines
        if(licenseTextLines == null) {
            System.out.println("No text license file: Cannot continue");
            abort = true;
            return;
        }
        // Make a backup if the file exists
        File bkpFile = null;
        if(file.exists()) {
            String inName = file.getPath();
            String bkpName = inName + ".BKP";
            bkpFile = new File(bkpName);
            if(bkpFile.exists()) {
                result = bkpFile.delete();
                if(!result) {
                    System.err.println("Failed to delete existing backup file:"
                        + LS + bkpFile.getPath());
                    abort = true;
                    return;
                }
            }
            result = file.renameTo(bkpFile);
            if(!result) {
                System.err.println("Failed to rename original file:" + LS
                    + bkpFile.getPath());
                abort = true;
                return;
            }
        }
        PrintWriter out = null;
        try {
            out = new PrintWriter(new FileWriter(file));
            for(int i = 0; i < licenseTextLines.length; i++) {
                out.println(licenseTextLines[i]);
            }
            // Cleanup
            out.close();
            out = null;
            if(file.exists() && bkpFile != null && bkpFile.exists()) {
                result = bkpFile.delete();
                if(!result) {
                    System.err.println("Failed to delete backup file:" + LS
                        + bkpFile.getPath());
                    abort = true;
                    return;
                }
            }
            System.out.println("  Done" + LS);
        } catch(Exception ex) {
            ex.printStackTrace();
        } finally {
            if(out != null) out.close();
        }
    }

    /**
     * Checks if a file has a name that ends with one of the binary extensions
     * in binaryExtensions.
     * 
     * @param file
     * @return
     */
    boolean isBinary(File file) {
        String ext = null;
        for(int i = 0; i < binaryExtensions.length; i++) {
            ext = binaryExtensions[i];
            if(file.getName().endsWith(ext)) return true;
            if(file.getName().endsWith(ext.toUpperCase())) return true;
        }
        return false;
    }

    boolean hasOldDomainName(File file) {
        // Do it
        BufferedReader in = null;
        try {
            in = new BufferedReader(new FileReader(file));
            String line;
            // int lineNum = 0;
            while((line = in.readLine()) != null) {
                // lineNum++;
                if(line.contains(oldDomainName)) {
                    return true;
                }
            }
        } catch(Exception ex) {
            ex.printStackTrace();
            return false;
        } finally {
            try {
                if(in != null) in.close();
            } catch(IOException ex) {
                ex.printStackTrace();
                abort = true;
                return false;
            }
        }
        return false;
    }

    /*
     * (non-Javadoc)
     * 
     * @see processtree.ProcessTree#parseCommand(java.lang.String[])
     */
    protected boolean parseCommand(String[] args) {
        int i;

        for(i = 0; i < args.length; i++) {
            if(args[i].startsWith("-")) {
                switch(args[i].charAt(1)) {
                case 'h':
                    usage();
                    System.exit(0);
                default:
                    System.err.println("\n\nInvalid option: " + args[i]);
                    usage();
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Generates a timestamp.
     * 
     * @return String timestamp
     */
    public static String timeStamp(long longDate) {
        Date date = new Date(longDate);
        final SimpleDateFormat defaultFormatter = new SimpleDateFormat(
            "M-dd-yyyy HH:mm:ss");
        return defaultFormatter.format(date);
    }

    /*
     * (non-Javadoc)
     * 
     * @see processtree.ProcessTree#usage()
     */
    protected void usage() {
        System.out.println("\nUsage: java " + this.getClass().getName()
            + " [Options]\n" + "  ProcessLicense: Process licenses\n"
            + "    -h        Help (This message)\n" + "");
    }

    /**
     * @param args
     */
    public static void main(String[] args) {
        ProcessLicense printTree = new ProcessLicense();
        if(!printTree.parseCommand(args)) {
            System.exit(1);
        }
        printTree.processDirectoryList();
        System.out.println();
        System.out.println("All done");
    }

}
